#include <iostream>
#include <iomanip>
#include <cstring>
#include "crypto_engine_scp03.h"
#include "sc_writer_scp03.h"

SmartCardCryptoSCP03::SmartCardCryptoSCP03() {
    memset(&state, 0, sizeof(state));
    state.channelActive = false;
    state.securityLevel = 0;
    state.commandCounter = 0;

    std::cout << "SCP03 Crypto Engine initialized (GP 2.2.1) with OpenSSL" << std::endl;
}

SmartCardCryptoSCP03::~SmartCardCryptoSCP03() {
    // Nothing to cleanup with OpenSSL
}

void SmartCardCryptoSCP03::setMasterKeys(const unsigned char* enc, const unsigned char* mac,
    const unsigned char* dek) {
    std::cout << "Master keys set for SCP03 derivation" << std::endl;
}

void SmartCardCryptoSCP03::setHostChallenge(const unsigned char* challenge, size_t length) {
    if (challenge && length >= 8) {
        memcpy(state.hostChallenge, challenge, 8);
        std::cout << "Host Challenge: ";
        for (int i = 0; i < 8; i++) printf("%02X ", state.hostChallenge[i]);
        std::cout << std::endl;
    }
}

bool SmartCardCryptoSCP03::performAES_ECB_Encrypt(const unsigned char* key,
    const unsigned char* input,
    unsigned char* output,
    size_t dataLen) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        std::cerr << "Failed to create cipher context" << std::endl;
        return false;
    }

    if (!EVP_EncryptInit_ex(ctx, EVP_aes_128_ecb(), NULL, key, NULL)) {
        std::cerr << "Failed to initialize encryption" << std::endl;
        EVP_CIPHER_CTX_free(ctx);
        return false;
    }

    EVP_CIPHER_CTX_set_padding(ctx, 0); // No padding

    int len = 0;
    if (!EVP_EncryptUpdate(ctx, output, &len, input, (int)dataLen)) {
        std::cerr << "Failed to encrypt data" << std::endl;
        EVP_CIPHER_CTX_free(ctx);
        return false;
    }

    int finalLen = 0;
    if (!EVP_EncryptFinal_ex(ctx, output + len, &finalLen)) {
        std::cerr << "Failed to finalize encryption" << std::endl;
        EVP_CIPHER_CTX_free(ctx);
        return false;
    }

    EVP_CIPHER_CTX_free(ctx);
    return true;
}

bool SmartCardCryptoSCP03::performAES_CBC_Encrypt(const unsigned char* key,
    const unsigned char* iv,
    const unsigned char* input,
    unsigned char* output,
    size_t dataLen) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        std::cerr << "Failed to create cipher context" << std::endl;
        return false;
    }

    if (!EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv)) {
        std::cerr << "Failed to initialize encryption" << std::endl;
        EVP_CIPHER_CTX_free(ctx);
        return false;
    }

    EVP_CIPHER_CTX_set_padding(ctx, 0); // No padding

    int len = 0;
    if (!EVP_EncryptUpdate(ctx, output, &len, input, (int)dataLen)) {
        std::cerr << "Failed to encrypt data" << std::endl;
        EVP_CIPHER_CTX_free(ctx);
        return false;
    }

    int finalLen = 0;
    if (!EVP_EncryptFinal_ex(ctx, output + len, &finalLen)) {
        std::cerr << "Failed to finalize encryption" << std::endl;
        EVP_CIPHER_CTX_free(ctx);
        return false;
    }

    EVP_CIPHER_CTX_free(ctx);
    return true;
}

bool SmartCardCryptoSCP03::performAES_CMAC(const unsigned char* key,
    const unsigned char* data,
    size_t dataLen,
    unsigned char* mac) {
    EVP_MAC* cmac = EVP_MAC_fetch(NULL, "CMAC", NULL);
    if (!cmac) {
        std::cerr << "Failed to fetch CMAC algorithm" << std::endl;
        return false;
    }

    EVP_MAC_CTX* ctx = EVP_MAC_CTX_new(cmac);
    EVP_MAC_free(cmac);

    if (!ctx) {
        std::cerr << "Failed to create CMAC context" << std::endl;
        return false;
    }

    OSSL_PARAM params[2];
    params[0] = OSSL_PARAM_construct_utf8_string("cipher", (char*)"AES-128-CBC", 0);
    params[1] = OSSL_PARAM_construct_end();

    if (!EVP_MAC_init(ctx, key, 16, params)) {
        std::cerr << "Failed to initialize CMAC" << std::endl;
        EVP_MAC_CTX_free(ctx);
        return false;
    }

    if (!EVP_MAC_update(ctx, data, dataLen)) {
        std::cerr << "Failed to update CMAC" << std::endl;
        EVP_MAC_CTX_free(ctx);
        return false;
    }

    size_t macLen = 16;
    if (!EVP_MAC_final(ctx, mac, &macLen, 16)) {
        std::cerr << "Failed to finalize CMAC" << std::endl;
        EVP_MAC_CTX_free(ctx);
        return false;
    }

    EVP_MAC_CTX_free(ctx);
    return (macLen == 16);
}

bool SmartCardCryptoSCP03::deriveGemaltoKey(const unsigned char* masterKey,
    const unsigned char* divData,
    size_t divDataLen,
    unsigned char keyType,
    unsigned char* derivedKey) {
    std::cout << "\n[Gemalto Key Diversification - FIXED]" << std::endl;

    // Correct KDF input per GlobalPlatform SCP03 spec:
    // Label || 0x00 || Context || L || i

    std::vector<unsigned char> kdfInput;

    // Label based on key type (11 bytes)
    unsigned char label[11] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                               0x00, 0x00, 0x00, 0x00, 0x00 };
    label[10] = keyType;  // 0x01 for ENC, 0x02 for MAC, 0x03 for DEK

    kdfInput.insert(kdfInput.end(), label, label + 11);

    // Separator
    kdfInput.push_back(0x00);

    // Context - use the diversification data
    kdfInput.insert(kdfInput.end(), divData, divData + divDataLen);

    // Length (L) - 128 bits = 0x0080
    kdfInput.push_back(0x00);
    kdfInput.push_back(0x80);

    // Counter (i) - always 0x01 for single block
    kdfInput.push_back(0x01);

    std::cout << "KDF Input: ";
    for (auto b : kdfInput) printf("%02X ", b);
    std::cout << std::endl;

    // Calculate CMAC
    unsigned char mac[16];
    if (!performAES_CMAC(masterKey, kdfInput.data(), kdfInput.size(), mac)) {
        std::cout << "CMAC calculation failed" << std::endl;
        return false;
    }

    memcpy(derivedKey, mac, 16);

    std::cout << "Derived Key: ";
    for (int i = 0; i < 16; i++) printf("%02X ", derivedKey[i]);
    std::cout << std::endl;

    return true;
}

// Alternative: Try the diversification data from INIT UPDATE directly
bool SmartCardCryptoSCP03::tryDirectDiversification(const std::vector<unsigned char>& initUpdateResponse) {
    std::cout << "\n=== TRYING DIRECT DIVERSIFICATION ===" << std::endl;

    // The first 10 bytes might not be zeros but actual diversification data
    // that we need to use to derive the card-specific keys

    unsigned char divData[10];
    memcpy(divData, initUpdateResponse.data(), 10);

    // Even though they look like zeros, they might be meaningful
    std::cout << "Diversification Data from card: ";
    for (int i = 0; i < 10; i++) printf("%02X ", divData[i]);
    std::cout << std::endl;

    unsigned char transportKey[16] = {
        0x1D, 0xDC, 0xD7, 0xAD, 0xBB, 0x1B, 0x5C, 0xDA,
        0x51, 0x93, 0xE9, 0x81, 0xF5, 0xE8, 0x68, 0x70
    };

    // Method 1: Use AES ECB encryption for diversification
    unsigned char divInput[16];
    memset(divInput, 0, 16);
    memcpy(divInput, divData, 10);

    // Add key type indicators
    unsigned char keyEnc[16], keyMac[16], keyDek[16];

    // For Key-ENC
    divInput[15] = 0x01;
    performAES_ECB_Encrypt(transportKey, divInput, keyEnc, 16);

    // For Key-MAC  
    divInput[15] = 0x02;
    performAES_ECB_Encrypt(transportKey, divInput, keyMac, 16);

    // For Key-DEK
    divInput[15] = 0x03;
    performAES_ECB_Encrypt(transportKey, divInput, keyDek, 16);

    std::cout << "Diversified Key-ENC: ";
    for (int i = 0; i < 16; i++) printf("%02X ", keyEnc[i]);
    std::cout << std::endl;

    std::cout << "Diversified Key-MAC: ";
    for (int i = 0; i < 16; i++) printf("%02X ", keyMac[i]);
    std::cout << std::endl;

    // Now use these diversified keys for session key derivation
    unsigned char context[16];
    memcpy(context, state.hostChallenge, 8);
    memcpy(context + 8, state.cardChallenge, 8);

    // Derive session keys with diversified master keys
    deriveSessionKey_SCP03(keyEnc, 0x01, context, 16, state.senc);
    deriveSessionKey_SCP03(keyMac, 0x02, context, 16, state.smac);
    deriveSessionKey_SCP03(keyMac, 0x03, context, 16, state.srmac);

    // Test card cryptogram with these keys
    unsigned char testCryptogram[8];
    calculateSCP03Cryptogram(state.smac, state.hostChallenge,
        state.cardChallenge, testCryptogram, false);

    std::cout << "Test Cryptogram: ";
    for (int i = 0; i < 8; i++) printf("%02X ", testCryptogram[i]);
    std::cout << std::endl;

    if (memcmp(testCryptogram, state.cardCryptogram, 8) == 0) {
        std::cout << "SUCCESS! Diversification method found!" << std::endl;
        return true;
    }

    return false;
}

bool SmartCardCryptoSCP03::deriveSessionKey_SCP03(const unsigned char* masterKey,
    uint8_t keyType,
    const unsigned char* context,
    size_t contextLen,
    unsigned char* derivedKey) {
    std::vector<unsigned char> derivationData;

    const unsigned char LABEL_ENC[11] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
    const unsigned char LABEL_MAC[11] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 };
    const unsigned char LABEL_RMAC[11] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03 };
    const unsigned char LABEL_DEK[11] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04 };

    const unsigned char* label = nullptr;
    switch (keyType) {
    case 0x01: label = LABEL_ENC; break;
    case 0x02: label = LABEL_MAC; break;
    case 0x03: label = LABEL_RMAC; break;
    case 0x04: label = LABEL_DEK; break;
    default: return false;
    }

    derivationData.insert(derivationData.end(), label, label + 11);
    derivationData.push_back(0x00);
    derivationData.push_back(0x00);
    derivationData.push_back(0x80);
    derivationData.push_back(0x01);

    if (context && contextLen > 0) {
        derivationData.insert(derivationData.end(), context, context + contextLen);
    }

    unsigned char fullMac[16];
    if (!performAES_CMAC(masterKey, derivationData.data(), derivationData.size(), fullMac)) {
        return false;
    }

    memcpy(derivedKey, fullMac, 16);
    return true;
}

void SmartCardCryptoSCP03::setDiversificationData(const std::vector<unsigned char>& data) {
    cardDiversificationData = data;
    std::cout << "Diversification data set (" << data.size() << " bytes): ";
    for (auto b : data) printf("%02X ", b);
    std::cout << std::endl;
}

void SmartCardCryptoSCP03::setInitUpdateResponse(const std::vector<unsigned char>& response) {
    initUpdateResponse = response;
    std::cout << "INIT UPDATE response stored (" << response.size() << " bytes)" << std::endl;
}

bool SmartCardCryptoSCP03::deriveKeyFromSerial(const unsigned char* masterKey,
    const unsigned char* serial,
    size_t serialLen,
    unsigned char* derivedKey) {
    // EMV-style diversification: Encrypt(MasterKey, Serial || F-Padding)
    unsigned char diversificationData[16];

    // Copy serial number
    memcpy(diversificationData, serial, (serialLen < 16) ? serialLen : 16);

    // Pad with 0xFF if serial is shorter than 16 bytes
    for (size_t i = serialLen; i < 16; i++) {
        diversificationData[i] = 0xFF;
    }

    // Encrypt with master key
    return performAES_ECB_Encrypt(masterKey, diversificationData, derivedKey, 16);
}

int SmartCardCryptoSCP03::initializeSecureChannel(const std::vector<unsigned char>& initUpdateResponse) {
    if (initUpdateResponse.size() < 28) {
        std::cerr << "INIT UPDATE response too short for SCP03 (need at least 28 bytes)" << std::endl;
        return -1;
    }

    std::cout << "\n=== SCP03 DIAGNOSTIC MODE ===" << std::endl;

    // Parse the response
    memcpy(state.cardChallenge, &initUpdateResponse[13], 8);    // bytes 13-20
    memcpy(state.cardCryptogram, &initUpdateResponse[21], 8);   // bytes 21-28
    memcpy(state.sequenceCounter, &initUpdateResponse[29], 3);  // bytes 29-31

    std::cout << "Card Challenge: ";
    for (int i = 0; i < 8; i++) printf("%02X ", state.cardChallenge[i]);
    std::cout << std::endl;

    std::cout << "Card Cryptogram: ";
    for (int i = 0; i < 8; i++) printf("%02X ", state.cardCryptogram[i]);
    std::cout << std::endl;

    std::cout << "Sequence Counter: ";
    for (int i = 0; i < 3; i++) printf("%02X ", state.sequenceCounter[i]);
    std::cout << std::endl;

    // === FIRST: TRY GEMALTO DIVERSIFICATION WITH IC SERIAL ===
    if (!cardDiversificationData.empty()) {
        std::cout << "\n=== ATTEMPTING GEMALTO DIVERSIFICATION ===" << std::endl;
        std::cout << "Using IC Serial: ";
        for (auto b : cardDiversificationData) printf("%02X ", b);
        std::cout << std::endl;

        // Test multiple potential master keys with Gemalto diversification
        std::vector<std::vector<unsigned char>> masterKeys = {
            // Your original transport key
            {0x1D, 0xDC, 0xD7, 0xAD, 0xBB, 0x1B, 0x5C, 0xDA, 0x51, 0x93, 0xE9, 0x81, 0xF5, 0xE8, 0x68, 0x70},

            // Common JCOP/JavaCard test keys
            {0x47, 0x45, 0x4D, 0x58, 0x54, 0x45, 0x53, 0x54, 0x4B, 0x45, 0x59, 0x53, 0x4A, 0x43, 0x4F, 0x50}, // GEMXTESTKEYSJCOP
            {0x67, 0x65, 0x6D, 0x78, 0x74, 0x65, 0x73, 0x74, 0x6B, 0x65, 0x79, 0x73, 0x6A, 0x63, 0x6F, 0x70}, // gemxtestkeysjcop
            {0x47, 0x45, 0x4D, 0x41, 0x4C, 0x54, 0x4F, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39}, // GEMALTO123456789
            {0x4A, 0x43, 0x4F, 0x50, 0x54, 0x45, 0x53, 0x54, 0x4B, 0x45, 0x59, 0x53, 0x31, 0x32, 0x33, 0x34}, // JCOPTESTKEYS1234

            // NXP keys
            {0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F},
            {0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50},

            // Zeroized and default keys
            {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
            {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
            {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10}
        };

        std::vector<std::string> keyNames = {
            "Transport Key", "GEMXTESTKEYSJCOP", "gemxtestkeysjcop", "GEMALTO123456789",
            "JCOPTESTKEYS1234", "NXP Default 1", "NXP Default 2", "All Zeros", "All FFs", "Sequential"
        };

        for (size_t keyIdx = 0; keyIdx < masterKeys.size(); keyIdx++) {
            std::cout << "\nTesting master key: " << keyNames[keyIdx] << std::endl;

            unsigned char* masterKey = masterKeys[keyIdx].data();

            // Derive keys using Gemalto method with this master key
            unsigned char derivedEnc[16], derivedMac[16], derivedDek[16];

            if (deriveGemaltoKey(masterKey, cardDiversificationData.data(),
                cardDiversificationData.size(), 0x01, derivedEnc) &&
                deriveGemaltoKey(masterKey, cardDiversificationData.data(),
                    cardDiversificationData.size(), 0x02, derivedMac)) {

                // Try calculating cryptogram with derived MAC key directly
                unsigned char testCryptogram[8];
                if (calculateSCP03Cryptogram(derivedMac, state.hostChallenge, state.cardChallenge,
                    testCryptogram, false)) {
                    std::cout << "  Cryptogram: ";
                    for (int i = 0; i < 8; i++) printf("%02X ", testCryptogram[i]);
                    std::cout << std::endl;

                    if (memcmp(testCryptogram, state.cardCryptogram, 8) == 0) {
                        std::cout << "  ✅ SUCCESS! Found working key: " << keyNames[keyIdx] << std::endl;

                        // Build standard context for session keys
                        unsigned char context[16];
                        memcpy(context, state.hostChallenge, 8);
                        memcpy(context + 8, state.cardChallenge, 8);

                        // Derive session keys
                        unsigned char senc[16], smac[16], srmac[16];
                        if (deriveSessionKey_SCP03(derivedEnc, 0x01, context, 16, senc) &&
                            deriveSessionKey_SCP03(derivedMac, 0x02, context, 16, smac) &&
                            deriveSessionKey_SCP03(derivedMac, 0x03, context, 16, srmac)) {

                            memcpy(state.senc, senc, 16);
                            memcpy(state.smac, smac, 16);
                            memcpy(state.srmac, srmac, 16);
                            memset(state.macChaining, 0, 16);
                            memset(state.encCounter, 0, 16);
                            return 0;
                        }
                    }
                }
            }
        }
        std::cout << "\n❌ No Gemalto diversification worked with any master key" << std::endl;
    }
    else {
        std::cout << "\n⚠️  No diversification data available, skipping Gemalto method" << std::endl;
    }

    // === SECOND: TRY DIRECT DIVERSIFICATION ===
    std::cout << "\n=== ATTEMPTING DIRECT DIVERSIFICATION ===" << std::endl;
    if (tryDirectDiversification(initUpdateResponse)) {
        return 0;
    }

    // === THIRD: FALL BACK TO ORIGINAL STATIC KEY TESTING ===
    // [KEEP ALL YOUR ORIGINAL STATIC KEY TESTING CODE EXACTLY AS IT WAS]
    // This ensures no syntax errors from missing code

    std::cout << "\n=== FALLING BACK TO STATIC KEY TESTING ===" << std::endl;

    // Try multiple master keys
    std::vector<std::vector<unsigned char>> testKeys = {
        // Your current key
        {0x1D, 0xDC, 0xD7, 0xAD, 0xBB, 0x1B, 0x5C, 0xDA,
         0x51, 0x93, 0xE9, 0x81, 0xF5, 0xE8, 0x68, 0x70},

         // Common default keys
         {0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
          0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F},

         {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

          // Another common test key
          {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}
    };

    std::vector<std::string> keyNames = {
        "Transport Key", "JCOP Default", "All Zeros", "All FFs"
    };

    bool foundMatch = false;
    unsigned char workingKey[16];

    for (size_t keyIdx = 0; keyIdx < testKeys.size(); keyIdx++) {
        std::cout << "\n=== Testing Key #" << (keyIdx + 1) << ": " << keyNames[keyIdx] << " ===" << std::endl;

        unsigned char* masterKey = testKeys[keyIdx].data();

        // Try different context variations
        std::vector<std::vector<unsigned char>> contexts;
        std::vector<std::string> contextNames;

        // Context 1: Standard (host || card)
        std::vector<unsigned char> ctx1(16);
        memcpy(ctx1.data(), state.hostChallenge, 8);
        memcpy(ctx1.data() + 8, state.cardChallenge, 8);
        contexts.push_back(ctx1);
        contextNames.push_back("Standard (host||card)");

        // Context 2: With sequence counter (host || card || seq)
        std::vector<unsigned char> ctx2(19);
        memcpy(ctx2.data(), state.hostChallenge, 8);
        memcpy(ctx2.data() + 8, state.cardChallenge, 8);
        memcpy(ctx2.data() + 16, state.sequenceCounter, 3);
        contexts.push_back(ctx2);
        contextNames.push_back("With Sequence (host||card||seq)");

        // Context 3: Sequence first (seq || host || card)
        std::vector<unsigned char> ctx3(19);
        memcpy(ctx3.data(), state.sequenceCounter, 3);
        memcpy(ctx3.data() + 3, state.hostChallenge, 8);
        memcpy(ctx3.data() + 11, state.cardChallenge, 8);
        contexts.push_back(ctx3);
        contextNames.push_back("Sequence First (seq||host||card)");

        for (size_t ctxIdx = 0; ctxIdx < contexts.size(); ctxIdx++) {
            std::cout << "\n  Testing context: " << contextNames[ctxIdx] << std::endl;

            // Derive session keys
            unsigned char senc[16], smac[16], srmac[16];

            if (!deriveSessionKey_SCP03(masterKey, 0x01, contexts[ctxIdx].data(), contexts[ctxIdx].size(), senc)) {
                continue;
            }
            if (!deriveSessionKey_SCP03(masterKey, 0x02, contexts[ctxIdx].data(), contexts[ctxIdx].size(), smac)) {
                continue;
            }
            if (!deriveSessionKey_SCP03(masterKey, 0x03, contexts[ctxIdx].data(), contexts[ctxIdx].size(), srmac)) {
                continue;
            }

            // Now try different cryptogram calculation methods
            unsigned char testCryptogram[8];

            // Method 1: Standard context for cryptogram
            if (calculateCryptogramDiagnostic(smac, state.hostChallenge, state.cardChallenge,
                NULL, 0, testCryptogram, false)) {
                std::cout << "    Method 1 (standard): ";
                for (int i = 0; i < 8; i++) printf("%02X ", testCryptogram[i]);

                if (memcmp(testCryptogram, state.cardCryptogram, 8) == 0) {
                    std::cout << " <- MATCH!" << std::endl;
                    foundMatch = true;
                    memcpy(workingKey, masterKey, 16);
                    memcpy(state.senc, senc, 16);
                    memcpy(state.smac, smac, 16);
                    memcpy(state.srmac, srmac, 16);
                    break;
                }
                else {
                    std::cout << std::endl;
                }
            }

            // Method 2: With sequence counter in cryptogram context
            if (calculateCryptogramDiagnostic(smac, state.hostChallenge, state.cardChallenge,
                state.sequenceCounter, 3, testCryptogram, false)) {
                std::cout << "    Method 2 (with seq): ";
                for (int i = 0; i < 8; i++) printf("%02X ", testCryptogram[i]);

                if (memcmp(testCryptogram, state.cardCryptogram, 8) == 0) {
                    std::cout << " <- MATCH!" << std::endl;
                    foundMatch = true;
                    memcpy(workingKey, masterKey, 16);
                    memcpy(state.senc, senc, 16);
                    memcpy(state.smac, smac, 16);
                    memcpy(state.srmac, srmac, 16);
                    break;
                }
                else {
                    std::cout << std::endl;
                }
            }

            // Method 3: Using the master key directly for cryptogram
            if (calculateCryptogramDiagnostic(masterKey, state.hostChallenge, state.cardChallenge,
                NULL, 0, testCryptogram, false)) {
                std::cout << "    Method 3 (master key): ";
                for (int i = 0; i < 8; i++) printf("%02X ", testCryptogram[i]);

                if (memcmp(testCryptogram, state.cardCryptogram, 8) == 0) {
                    std::cout << " <- MATCH!" << std::endl;
                    foundMatch = true;
                    memcpy(workingKey, masterKey, 16);
                    // Still use derived session keys
                    memcpy(state.senc, senc, 16);
                    memcpy(state.smac, smac, 16);
                    memcpy(state.srmac, srmac, 16);
                    break;
                }
                else {
                    std::cout << std::endl;
                }
            }
        }

        if (foundMatch) break;
    }

    if (foundMatch) {
        std::cout << "\n=== SUCCESS! Found working configuration ===" << std::endl;
        std::cout << "Working Master Key: ";
        for (int i = 0; i < 16; i++) printf("%02X ", workingKey[i]);
        std::cout << std::endl;

        std::cout << "Session Keys:" << std::endl;
        std::cout << "S-ENC: ";
        for (int i = 0; i < 16; i++) printf("%02X ", state.senc[i]);
        std::cout << std::endl;
        std::cout << "S-MAC: ";
        for (int i = 0; i < 16; i++) printf("%02X ", state.smac[i]);
        std::cout << std::endl;
        std::cout << "S-RMAC: ";
        for (int i = 0; i < 16; i++) printf("%02X ", state.srmac[i]);
        std::cout << std::endl;

        memset(state.macChaining, 0, 16);
        memset(state.encCounter, 0, 16);
        return 0;
    }
    else {
        std::cout << "\n=== FAILED: No matching configuration found ===" << std::endl;
        std::cout << "The card may be using:" << std::endl;
        std::cout << "- A different master key" << std::endl;
        std::cout << "- Key diversification based on card serial" << std::endl;
        std::cout << "- A proprietary SCP03 variant" << std::endl;
        return -1;
    }
}

// Diagnostic cryptogram calculation that can try different contexts
bool SmartCardCryptoSCP03::calculateCryptogramDiagnostic(const unsigned char* key,
    const unsigned char* hostChallenge,
    const unsigned char* cardChallenge,
    const unsigned char* extraData,
    size_t extraLen,
    unsigned char* cryptogram,
    bool isHostCryptogram) {
    std::vector<unsigned char> derivationData;

    // Label with derivation constant
    unsigned char label[11] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    label[10] = isHostCryptogram ? 0x01 : 0x00;

    derivationData.insert(derivationData.end(), label, label + 11);
    derivationData.push_back(0x00);  // Separator
    derivationData.push_back(0x00);  // L MSB
    derivationData.push_back(0x40);  // L LSB
    derivationData.push_back(0x01);  // Counter i

    // Context
    derivationData.insert(derivationData.end(), hostChallenge, hostChallenge + 8);
    derivationData.insert(derivationData.end(), cardChallenge, cardChallenge + 8);

    // Optional extra data (like sequence counter)
    if (extraData && extraLen > 0) {
        derivationData.insert(derivationData.end(), extraData, extraData + extraLen);
    }

    unsigned char fullMac[16];
    if (!performAES_CMAC(key, derivationData.data(), derivationData.size(), fullMac)) {
        return false;
    }

    memcpy(cryptogram, fullMac, 8);
    return true;
}

bool SmartCardCryptoSCP03::calculateSCP03Cryptogram(const unsigned char* key,
    const unsigned char* hostChallenge,
    const unsigned char* cardChallenge,
    unsigned char* cryptogram,
    bool isHostCryptogram) {
    std::vector<unsigned char> derivationData;

    // Label: 11 bytes with derivation constant
    // Per GP spec Table 4-1: 0x00 for card, 0x01 for host
    unsigned char label[11] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    label[10] = isHostCryptogram ? 0x01 : 0x00;

    derivationData.insert(derivationData.end(), label, label + 11);
    derivationData.push_back(0x00);  // Separator
    derivationData.push_back(0x00);  // L MSB
    derivationData.push_back(0x40);  // L LSB (64 bits = 8 bytes cryptogram)
    derivationData.push_back(0x01);  // Counter i

    // Context per GP spec 6.2.2.2 and 6.2.2.3:
    // "The context parameter shall be set to the concatenation of 
    //  the host challenge and the card challenge"
    // NO sequence counter in the context!
    derivationData.insert(derivationData.end(), hostChallenge, hostChallenge + 8);
    derivationData.insert(derivationData.end(), cardChallenge, cardChallenge + 8);

    std::cout << "Cryptogram Derivation Input ("
        << (isHostCryptogram ? "HOST" : "CARD") << "): ";
    for (auto b : derivationData) printf("%02X ", b);
    std::cout << std::endl;

    unsigned char fullMac[16];
    if (!performAES_CMAC(key, derivationData.data(), derivationData.size(), fullMac)) {
        return false;
    }

    // Take first 8 bytes as cryptogram
    memcpy(cryptogram, fullMac, 8);
    return true;
}

std::vector<unsigned char> SmartCardCryptoSCP03::createExternalAuthenticateCommand(uint8_t securityLevel) {
    std::vector<unsigned char> apdu;

    if (!state.smac[0] && !state.smac[1]) {
        std::cerr << "ERROR: Session keys not initialized" << std::endl;
        return apdu;
    }

    std::cout << "\n=== SCP03 EXTERNAL AUTHENTICATE ===" << std::endl;

    // Calculate host cryptogram using the FIXED method
    unsigned char hostCryptogram[8];
    if (!calculateSCP03Cryptogram(state.smac, state.hostChallenge,
        state.cardChallenge, hostCryptogram, true)) {
        std::cerr << "Failed to calculate host cryptogram" << std::endl;
        return apdu;
    }

    std::cout << "Host Cryptogram: ";
    for (int i = 0; i < 8; i++) printf("%02X ", hostCryptogram[i]);
    std::cout << std::endl;

    // Build EXTERNAL AUTHENTICATE command
    apdu = { 0x84, 0x82, securityLevel, 0x00, 0x10 };
    apdu.insert(apdu.end(), hostCryptogram, hostCryptogram + 8);

    // Reserve space for MAC
    apdu.insert(apdu.end(), 8, 0x00);

    // Calculate C-MAC
    std::vector<unsigned char> macInput;

    // MAC chaining value (initially all zeros)
    macInput.insert(macInput.end(), state.macChaining, state.macChaining + 16);

    // Command header + data (excluding MAC)
    macInput.insert(macInput.end(), apdu.begin(), apdu.begin() + 13);

    std::cout << "\n=== MAC CALCULATION ===" << std::endl;
    std::cout << "MAC Chaining Value: ";
    for (int i = 0; i < 16; i++) printf("%02X ", state.macChaining[i]);
    std::cout << std::endl;

    std::cout << "MAC Input Data: ";
    for (auto b : macInput) printf("%02X ", b);
    std::cout << std::endl;

    unsigned char mac[16];
    if (!performAES_CMAC(state.smac, macInput.data(), macInput.size(), mac)) {
        std::cerr << "Failed to calculate MAC" << std::endl;
        return {};
    }

    std::cout << "Full MAC Output: ";
    for (int i = 0; i < 16; i++) printf("%02X ", mac[i]);
    std::cout << std::endl;

    std::cout << "Using First 8 Bytes: ";
    for (int i = 0; i < 8; i++) printf("%02X ", mac[i]);
    std::cout << std::endl;

    // Update MAC chaining value for next command
    memcpy(state.macChaining, mac, 16);

    // Insert MAC into command (8 bytes)
    memcpy(&apdu[13], mac, 8);

    std::cout << "Final Command: ";
    for (auto b : apdu) printf("%02X ", b);
    std::cout << std::endl;

    state.securityLevel = securityLevel;
    state.channelActive = true;

    return apdu;
}

void SmartCardCryptoSCP03::addISO9797_M2Padding(std::vector<unsigned char>& data) {
    data.push_back(0x80);
    while (data.size() % 16 != 0) {
        data.push_back(0x00);
    }
}

void SmartCardCryptoSCP03::removeISO9797_M2Padding(std::vector<unsigned char>& data) {
    while (!data.empty() && data.back() == 0x00) {
        data.pop_back();
    }
    if (!data.empty() && data.back() == 0x80) {
        data.pop_back();
    }
}

bool SmartCardCryptoSCP03::calculateCommandMAC(const std::vector<unsigned char>& apdu,
    unsigned char* mac) {
    std::vector<unsigned char> macInput;
    macInput.insert(macInput.end(), state.macChaining, state.macChaining + 16);
    macInput.insert(macInput.end(), apdu.begin(), apdu.end());

    unsigned char fullMac[16];
    if (!performAES_CMAC(state.smac, macInput.data(), macInput.size(), fullMac)) {
        return false;
    }

    memcpy(state.macChaining, fullMac, 16);
    memcpy(mac, fullMac, 8);
    return true;
}

std::vector<unsigned char> SmartCardCryptoSCP03::wrapCommandAPDU(const std::vector<unsigned char>& plainAPDU) {
    if (!state.channelActive) {
        std::cerr << "Secure channel not active" << std::endl;
        return plainAPDU;
    }

    if (plainAPDU.size() < 4) {
        std::cerr << "Invalid APDU" << std::endl;
        return plainAPDU;
    }

    std::vector<unsigned char> wrappedAPDU;

    uint8_t cla = plainAPDU[0];
    uint8_t ins = plainAPDU[1];
    uint8_t p1 = plainAPDU[2];
    uint8_t p2 = plainAPDU[3];

    cla |= 0x04;

    bool hasMac = (state.securityLevel & 0x01) != 0;
    bool hasEnc = (state.securityLevel & 0x02) != 0;

    wrappedAPDU.push_back(cla);
    wrappedAPDU.push_back(ins);
    wrappedAPDU.push_back(p1);
    wrappedAPDU.push_back(p2);

    std::vector<unsigned char> data;
    if (plainAPDU.size() > 5) {
        uint8_t lc = plainAPDU[4];
        if (plainAPDU.size() >= 5 + lc) {
            data.insert(data.end(), plainAPDU.begin() + 5, plainAPDU.begin() + 5 + lc);
        }
    }

    if (hasEnc && !data.empty()) {
        addISO9797_M2Padding(data);

        std::vector<unsigned char> encrypted(data.size());
        if (!performAES_CBC_Encrypt(state.senc, state.encCounter,
            data.data(), encrypted.data(), data.size())) {
            std::cerr << "Encryption failed" << std::endl;
            return plainAPDU;
        }
        data = encrypted;
    }

    size_t finalLc = data.size() + (hasMac ? 8 : 0);
    wrappedAPDU.push_back((uint8_t)finalLc);
    wrappedAPDU.insert(wrappedAPDU.end(), data.begin(), data.end());

    if (hasMac) {
        unsigned char mac[8];
        if (!calculateCommandMAC(wrappedAPDU, mac)) {
            std::cerr << "MAC calculation failed" << std::endl;
            return plainAPDU;
        }
        wrappedAPDU.insert(wrappedAPDU.end(), mac, mac + 8);
        wrappedAPDU[4] = (uint8_t)finalLc;
    }

    return wrappedAPDU;
}

std::vector<unsigned char> SmartCardCryptoSCP03::unwrapResponseAPDU(const std::vector<unsigned char>& wrappedResponse) {
    if (!state.channelActive) {
        return wrappedResponse;
    }
    return wrappedResponse;
}

bool SmartCardCryptoSCP03::isSecureChannelActive() const {
    return state.channelActive;
}

uint8_t SmartCardCryptoSCP03::getSecurityLevel() const {
    return state.securityLevel;
}

uint32_t SmartCardCryptoSCP03::getCommandCounter() const {
    return state.commandCounter;
}

void SmartCardCryptoSCP03::printSessionKeys() const {
    std::cout << "\n=== SCP03 SESSION KEYS ===" << std::endl;
    std::cout << "S-ENC:  ";
    for (int i = 0; i < 16; i++) printf("%02X ", state.senc[i]);
    std::cout << "\nS-MAC:  ";
    for (int i = 0; i < 16; i++) printf("%02X ", state.smac[i]);
    std::cout << "\nS-RMAC: ";
    for (int i = 0; i < 16; i++) printf("%02X ", state.srmac[i]);
    std::cout << std::endl;
}

void SmartCardCryptoSCP03::printMacChainingValue() const {
    std::cout << "MAC Chaining: ";
    for (int i = 0; i < 16; i++) printf("%02X ", state.macChaining[i]);
    std::cout << std::endl;
}

void SmartCardCryptoSCP03::resetChannel() {
    memset(&state, 0, sizeof(state));
    state.channelActive = false;
    state.securityLevel = 0;
    state.commandCounter = 0;
    std::cout << "SCP03 channel reset" << std::endl;
}
